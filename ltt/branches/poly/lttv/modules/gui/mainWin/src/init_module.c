/*
 * Initial main.c file generated by Glade. Edit as required.
 * Glade will not overwrite this file.
 */

#ifdef HAVE_CONFIG_H
#  include <config.h>
#endif

#include <gtk/gtk.h>

#include <lttv/lttv.h>
#include <lttv/attribute.h>
#include <lttv/hook.h>
#include <lttv/option.h>
#include <lttv/module.h>
#include <lttv/processTrace.h>
#include <lttv/state.h>
#include <lttv/stats.h>
#include <lttv/menu.h>
#include <lttv/toolbar.h>

#include "interface.h"
#include "support.h"
#include <lttv/mainWindow.h>
#include "callbacks.h"

/* global variable */
systemView * gSysView;

LttvTracesetStats * gTracesetContext = NULL;
static LttvTraceset * traceset;

/** Array containing instanced objects. */
GSList * Main_Window_List = NULL ;

static LttvHooks 
  *before_traceset,
  *after_traceset,
  *before_trace,
  *after_trace,
  *before_tracefile,
  *after_tracefile,
  *before_event,
  *after_event,
  *main_hooks;

static char *a_trace;

void lttv_trace_option(void *hook_data)
{ 
  LttTrace *trace;

  trace = ltt_trace_open(a_trace);
  if(trace == NULL) g_critical("cannot open trace %s", a_trace);
  lttv_traceset_add(traceset, trace);
}

/*****************************************************************************
 *                 Functions for module loading/unloading                    *
 *****************************************************************************/
/**
 * plugin's init function
 *
 * This function initializes the GUI.
 */

static gboolean Window_Creation_Hook(void *hook_data, void *call_data)
{
  int i;
  GdkPixbuf *pixbuf;
  view_constructor constructor;
  LttvMenus * menu;
  LttvToolbars * toolbar;
  lttv_menu_closure *menuItem;
  lttv_toolbar_closure *toolbarItem;
  LttvAttributeValue value;
  LttvIAttribute *attributes = LTTV_IATTRIBUTE(lttv_global_attributes());
  GModule *gm;
  GtkWidget * ToolMenuTitle_menu, *insert_view, *pixmap;
  GtkWidget *window1;
  mainWindow * mw = g_new(mainWindow, 1);
  gSysView = g_new(systemView, 1);
  WindowCreationData *Window_Creation_Data = (WindowCreationData*)hook_data;

  mw->winCreationData = Window_Creation_Data;

  /* Add the object's information to the module's array */
  Main_Window_List = g_slist_append(Main_Window_List, mw);

  g_critical("GUI Window_Creation_Hook()");
#ifdef ENABLE_NLS
  bindtextdomain (GETTEXT_PACKAGE, PACKAGE_LOCALE_DIR);
  bind_textdomain_codeset (GETTEXT_PACKAGE, "UTF-8");
  textdomain (GETTEXT_PACKAGE);
#endif

  gtk_set_locale ();
  gtk_init (&(Window_Creation_Data->argc), &(Window_Creation_Data->argv));

  add_pixmap_directory (PACKAGE_DATA_DIR "/" PACKAGE "/pixmaps");
  add_pixmap_directory ("pixmaps");
  add_pixmap_directory ("modules/gui/mainWin/pixmaps");

  /*
   * The following code was added by Glade to create one of each component
   * (except popup menus), just so that you see something after building
   * the project. Delete any components that you don't want shown initially.
   */
  window1 = create_MWindow ();
  gtk_widget_show (window1);

  mw->MWindow = window1;
  mw->SystemView = gSysView;
  mw->Tab = NULL;
  mw->CurrentTab = NULL;
  mw->Attributes = LTTV_IATTRIBUTE(g_object_new(LTTV_ATTRIBUTE_TYPE, NULL));
  if(!gTracesetContext){
    gTracesetContext = g_object_new(LTTV_TRACESET_STATS_TYPE, NULL);
    //FIXME: lttv_context_fini should be called some where.
    lttv_context_init(LTTV_TRACESET_CONTEXT(gTracesetContext), traceset);
  }
  mw->traceset_context = LTTV_TRACESET_CONTEXT(gTracesetContext);
  mw->traceset = (LTTV_TRACESET_CONTEXT(gTracesetContext))->ts;
  g_object_ref(gTracesetContext);

  //test
  g_assert(lttv_iattribute_find_by_path(attributes,
	   "viewers/menu", LTTV_POINTER, &value));
  menu = (LttvMenus*)*(value.v_pointer);

  if(menu){
    for(i=0;i<menu->len;i++){
      menuItem = &g_array_index(menu, lttv_menu_closure, i);
      constructor = menuItem->con;
      ToolMenuTitle_menu = lookup_widget(mw->MWindow,"ToolMenuTitle_menu");
      insert_view = gtk_menu_item_new_with_mnemonic (menuItem->menuText);
      gtk_widget_show (insert_view);
      gtk_container_add (GTK_CONTAINER (ToolMenuTitle_menu), insert_view);
      g_signal_connect ((gpointer) insert_view, "activate",
			G_CALLBACK (insertViewTest),
			constructor);  
    }
  }

  g_assert(lttv_iattribute_find_by_path(attributes,
	   "viewers/toolbar", LTTV_POINTER, &value));
  toolbar = (LttvToolbars*)*(value.v_pointer);

  if(toolbar){
    for(i=0;i<toolbar->len;i++){
      toolbarItem = &g_array_index(toolbar, lttv_toolbar_closure, i);
      constructor = toolbarItem->con;
      ToolMenuTitle_menu = lookup_widget(mw->MWindow,"MToolbar2");
      pixbuf = gdk_pixbuf_new_from_xpm_data ((const char**)toolbarItem->pixmap);
      pixmap = gtk_image_new_from_pixbuf(pixbuf);
      insert_view = gtk_toolbar_append_element (GTK_TOOLBAR (ToolMenuTitle_menu),
						GTK_TOOLBAR_CHILD_BUTTON,
						NULL,
						"",
						toolbarItem->tooltip, NULL,
						pixmap, NULL, NULL);
      gtk_label_set_use_underline (GTK_LABEL (((GtkToolbarChild*) (g_list_last (GTK_TOOLBAR (ToolMenuTitle_menu)->children)->data))->label), TRUE);
      gtk_widget_show (insert_view);
      gtk_container_set_border_width (GTK_CONTAINER (insert_view), 1);
      g_signal_connect ((gpointer) insert_view, "clicked",G_CALLBACK (insertViewTest),constructor);       
    }
  }

  //end

  gSysView->EventDB = NULL;
  gSysView->SystemInfo = NULL;
  gSysView->Options  = NULL;
  gSysView->Window = mw;
  gSysView->Next = NULL;

  g_object_set_data(G_OBJECT(window1), "systemView", (gpointer)gSysView);
  g_object_set_data(G_OBJECT(window1), "mainWindow", (gpointer)mw);

  gtk_main ();

  return FALSE;
}




G_MODULE_EXPORT void init(LttvModule *self, int argc, char *argv[]) {

  LttvAttributeValue value;
  WindowCreationData *Window_Creation_Data = g_new(WindowCreationData, 1);
  
  LttvIAttribute *attributes = LTTV_IATTRIBUTE(lttv_global_attributes());
  
  g_critical("GUI init()");
  
  lttv_option_add("trace", 't', 
      "add a trace to the trace set to analyse", 
      "pathname of the directory containing the trace", 
      LTTV_OPT_STRING, &a_trace, lttv_trace_option, NULL);

  traceset = lttv_traceset_new();

  before_traceset = lttv_hooks_new();
  after_traceset = lttv_hooks_new();
  before_trace = lttv_hooks_new();
  after_trace = lttv_hooks_new();
  before_tracefile = lttv_hooks_new();
  after_tracefile = lttv_hooks_new();
  before_event = lttv_hooks_new();
  after_event = lttv_hooks_new();

  g_assert(lttv_iattribute_find_by_path(attributes, "hooks/traceset/before",
      LTTV_POINTER, &value));
  *(value.v_pointer) = before_traceset;
  g_assert(lttv_iattribute_find_by_path(attributes, "hooks/traceset/after",
      LTTV_POINTER, &value));
  *(value.v_pointer) = after_traceset;
  g_assert(lttv_iattribute_find_by_path(attributes, "hooks/trace/before",
      LTTV_POINTER, &value));
  *(value.v_pointer) = before_trace;
  g_assert(lttv_iattribute_find_by_path(attributes, "hooks/trace/after",
      LTTV_POINTER, &value));
  *(value.v_pointer) = after_trace;
  g_assert(lttv_iattribute_find_by_path(attributes, "hooks/tracefile/before",
      LTTV_POINTER, &value));
  *(value.v_pointer) = before_tracefile;
  g_assert(lttv_iattribute_find_by_path(attributes, "hooks/tracefile/after",
      LTTV_POINTER, &value));
  *(value.v_pointer) = after_tracefile;
  g_assert(lttv_iattribute_find_by_path(attributes, "hooks/event/before",
      LTTV_POINTER, &value));
  *(value.v_pointer) = before_event;
  g_assert(lttv_iattribute_find_by_path(attributes, "hooks/event/after",
      LTTV_POINTER, &value));
  *(value.v_pointer) = after_event;

  g_assert(lttv_iattribute_find_by_path(attributes, "hooks/main/before",
      LTTV_POINTER, &value));
  g_assert((main_hooks = *(value.v_pointer)) != NULL);

  Window_Creation_Data->argc = argc;
  Window_Creation_Data->argv = argv;
  
  lttv_hooks_add(main_hooks, Window_Creation_Hook, Window_Creation_Data);

}

void destroy_walk(gpointer data, gpointer user_data)
{
	//GuiControlFlow_Destructor((ControlFlowData*)data);
}



/**
 * plugin's destroy function
 *
 * This function releases the memory reserved by the module and unregisters
 * everything that has been registered in the gtkTraceSet API.
 */
G_MODULE_EXPORT void destroy() {

  WindowCreationData *Window_Creation_Data;
  LttvAttributeValue value;

  guint i, nb;

  lttv_option_remove("trace");

  lttv_hooks_destroy(before_traceset);
  lttv_hooks_destroy(after_traceset);
  lttv_hooks_destroy(before_trace);
  lttv_hooks_destroy(after_trace);
  lttv_hooks_destroy(before_tracefile);
  lttv_hooks_destroy(after_tracefile);
  lttv_hooks_destroy(before_event);
  lttv_hooks_destroy(after_event);
  lttv_hooks_remove_data(main_hooks, Window_Creation_Hook, NULL);

  nb = lttv_traceset_number(traceset);
  for(i = 0 ; i < nb ; i++) {
    ltt_trace_close(lttv_traceset_get(traceset, i));
  }

  lttv_traceset_destroy(traceset); 

  g_critical("GUI destroy()");



  //ControlFlowData *Control_Flow_Data;
  

  g_slist_foreach(Main_Window_List, destroy_walk, NULL );
  
  
  //lttv_hooks_remove_data(main_hooks,Window_Creation_Hook, NULL);
  //lttv_hooks_remove_data(before_traceset, get_traceset_context, NULL);

  //  g_free(Window_Creation_Data);

  g_object_unref(gTracesetContext);
}




